*ViT.txt*	Plugin for extended LaTeX support in Vim.
		Last change: 2021 Dec 19

ViT						    *vit* *vit-toc*
==============================================================================

1. Introduction					    |vit-intro|
2. Configuration Options			    |vit-config|
    2.a The |g:vit_leader| option
    2.b The |g:vit_compiler| option
    2.c The |g:vit_compiler_flags| option
    2.d The |g:vit_max_errors| option
    2.e The |g:vit_error_regexp| option
    2.f The |g:vit_error_line_regexp| option
    2.g The |g:vit_jump_chars| option
    2.h The |g:vit_template_remove_on_abort| option
    2.i The |g:vit_comment_line| option
    2.j The |g:vit_commands| option
    2.k The |g:vit_autosurround_chars| option
3. Templates					    |vit-templates|
    3.a Definition of new Templates		    |vit-templates-new|
    3.b Builtin Templates			    |vit-templates-builtin|
4. Insert-Mode Completion			    |vit-completion|
5. Compiling					    |vit-compiling|
6. Smart Typing					    |vit-smart-typing|
7. License					    |vit-license|

==============================================================================
1. Introduction					    *vit-intro*

ViT aims to be a fairly configurable, nicely integrated, and reliable plugin
to aid in typesetting specifically mathematics in LaTeX. It comes with many
predefined settings, commands, and templates which can help to start using
ViT right away. The goal is to make ViT very intuitive and to take away as
much repetitive typing effort as possible.

This plugin is mainly intended to aid in my specific workflow, but if you feel
you can gain something from using it, then you are more than welcome to.

GitHub page: https://github.com/MarcelSimader/ViT

See |vit-license| for licensing details.

==============================================================================
2. Configuration Options			    *vit-config*

------------------------------------------------------------------------------
2.a The *g:vit_leader* option (string)

Sets the leader key for keybinds in ViT. See <ViT> in |vit-templates-builtin|
for example.
Default value: >
    let g:vit_leader = '<C-@>'
<
------------------------------------------------------------------------------
2.b The *g:vit_compiler* option (string)

Sets the command that is used to compile the current buffer.
Default value: >
    let g:vit_compiler = 'pdflatex'
<
------------------------------------------------------------------------------
2.c The *g:vit_compiler_flags* option (string)

Sets the flags for the command specified by |g:vit_compiler|.
Default value: >
    let g:vit_compiler_flags = ''
<
------------------------------------------------------------------------------
2.d The *g:vit_max_errors* option (number)

Sets the maximum number of errors that are matched by |g:vit_error_regexp| and
|g:vit_error_line_regexp|.
Default value: >
    let g:vit_max_errors = 3
<
------------------------------------------------------------------------------
2.e The *g:vit_error_regexp* option (string)

Sets the regular expression that is used to match error output in a .log file
generated by compiling the current buffer using |g:vit_compiler|.
Default value: >
    let g:vit_error_regexp = '!\s*\(.*\)'
<
------------------------------------------------------------------------------
2.f The *g:vit_error_line_regexp* option (string)

Sets the regular expression that is used to match the line numbers indicating
where an error happened generated by compiling the current buffer using
|g:vit_compiler|.
Default value: >
    let g:vit_error_line_regexp = '^l\.\d\+'
<
------------------------------------------------------------------------------
2.g The *g:vit_jump_chars* option (list of strings)

Sets the characters that are considered when using the smart-move right
feature of ViT (see |i_<S-Tab>|). The priority of the character is the
position of the character in the list.
Default value: >
    let g:vit_jump_chars = [' ', '(', '[', '{']
<
------------------------------------------------------------------------------
2.h The *g:vit_template_remove_on_abort* option (boolean)

Sets whether or not templates with template arguments are removed again upon
aborting them (i.e. leaving an argument blank).
Default value: >
    let g:vit_template_remove_on_abort = 1
<
------------------------------------------------------------------------------
2.i The *g:vit_comment_line* option (string)

Sets what string to use for full-line comment separators.
Default value: >
    let g:vit_comment_line = '% '.repeat('~', 70)
<
------------------------------------------------------------------------------
2.j The *g:vit_commands* option (list of strings)

Sets the commands used for static completion (see |vit-completion|). Per
default, this value is read from a file called 'latex_commands.txt' which has
one command per line, with optional empty lines. One can replace this file and
place it anywhere in the 'runtimepath' of Vim to use a different set of static
completion items.
Default value: >
    try
        let g:vit_commands = readfile(findfile('latex_commands.txt'))
    catch
	let g:vit_commands = []
    endtry
<
------------------------------------------------------------------------------
2.k The *g:vit_autosurround_chars* option (list of [string, string] lists)

Sets the chars that are automatically surrounded in insert mode. I.e. the
first index is listened for, and then the second index is inserted after the
cursor (see |vit-autosurround|).
Default value: >
    let g:vit_autosurround_chars = [
	\ ['(', ')'], ['[', ']'], ['{', '}'], ['$', '$']
	\ ]
<
==============================================================================
3. Templates					    *vit-templates*

Templates are a convenient way to insert more complex LaTeX structures into
your document, without having to type out the full thing.

------------------------------------------------------------------------------
3.a Definition of new Templates			    *vit-templates-new*

Templates are defined using the |ViTNewTemplate()| function.

A new template definition is easy to add, just add a new file containing the
definitions. For instance, here we will choose 'definitions.vim'. The file
could look like this: >
    call ViTNewTemplate('MyTemplate', '<F6>', 0, 0, [], 0,
			\ ['This is some text'], ['This is some more text'])
Then add the following |:autocmd| wrapped in an |:augroup| to your vimrc: >
    augroup MyDefinitions
	autocmd!
	autocmd FileType latex source path-to-definitions.vim
    augroup END
This autocommand will wait for the ViT-provided latex filetype plugin to load
and then include your template definitions, or anything else you added to
'definitions.vim'.

						    *vit-templates-arguments*
A template with arguments may contain an arbitrary number of template
placeholders with the text '#1', '#2', '#3', ... They must be ordered from 1
to {numargs} (see |ViTNewTemplate()|) but each template placeholder may be put
in as many lines as many times as desired. For an example, see |vit-env|.

Unfortunately, there is no way yet to include the literal '#1' without it
being replaced by the template insertion. However, the user may just
manually put '#1' when asked for the replacement text.

						    *ViTNewTemplate()*
ViTNewTemplate({name}, {keybind}, {inlinemode}, {completionitem}
	       {finalcursoroffset}, {middleindent},
	       {textbefore}, {textafter} [, {numargs}
	       [, {argname} [, {argdefault} [, {argcomplete}]]]])
	The |ViTNewTemplate()| function will register a new template command
	with the ViT plugin. The operation mode of the created command depends
	on the current mode (|vim-modes|) and the truthiness of {inlinemode}:

	Normal Mode: ~
	    Both:	     Insert the template at the cursor position.
	Insert Mode: ~
	    Non-Inline Mode: Surround the cursor line with the template
			     using newlines.
	    Inline Mode:     Insert the template at the cursor position.
	Character Visual Mode: ~
	    Both:	     Surround the selection.
	Line Visual Mode: ~
	    Both:	     Surround the selected lines with the template
			     using newlines.

	For instance, in insert mode with {inlinemode} set to true, the
        template |vit-parentheses| will produce the following output: >
	    ...\left(  \right)...
<	But without {inlinemode} it would do the following: >
	    \left(
	    ......
	    \right)
<
	The function will do the following steps, depending on the arguments
	provided, where steps 3. and 4. depend on {keybind} being non-empty,
	and '{ompletionitem} being set respectively:
	    1. Define the behavior of the command to do:
		1.a. Insert {textbefore} and {textafter} surrounding the
		     to-be surrounded text.
		2.b. Replace the template arguments if there are any (see
		     |vit-templates-arguments|).
	    2. Define a new command with name {name}.
	    [3. Set up a keybind for the command with {keybind}.]
	    [4. Register the command with the |vit-completion| system.]

	The {finalcursoroffset} argument must be of form [] for no action,
	[line] for putting the cursor in the specified line at column 0, or
	[line, col] for putting the cursor in the specified line and column.
	These positions are relative to the start of the template in the
	document.

	The {middleindent} option will indent all the middle lines by the
	specified number of spaces. For instance with |vit-center| (set to 4): >
	    \beign{center}
	        ...
	    \end{center}
<
	The {textbefore} ({textafter}) option is a list of strings of text
	that is inserted before (after) the to-be surrounded text. These
	may be left empty by passing [].

	The {numargs}, {argname}, {argdefault}, and {argcomplete} options
	specify the number of templating arguments (defaults to 0), the
	optional names of these arguments, their optional default value, and
	their optional completion modi as specified by |input()|.

------------------------------------------------------------------------------
3.b Builtin Templates				    *vit-templates-builtin*

ViT comes with a number of predefined |vit-templates|. All of these templates
contain at least a command and possibly a keyboard shortcut. A '*' in the
template text indicates the final cursor position. A '#1', '#2', and so on,
indicates a template argument insertion spot. When in visual mode, a '*' also
indicates where surrounded text will go. See |vit-templates-new| for
information on normal and inline templates.

Mode table for the commands and keybinds:

	    Normal Mode	    Insert Mode	    Visual Mode
Command		y		y		y
Keybind		n		y		y

						    *<ViT>*
<ViT> is a placeholder for the value configured in |g:vit_leader|.

						    *vit-env*
:ViTEnv	or <C-E>	    Starts a simple environment template: >
			    \begin{#1}
				*
			    \end{#1}
<						    *vit-enum* *vit-enum-left*
						    *vit-enum-alph*
						    *vit-center* *vit-tabular*
:ViTEnum or |<ViT>|e	    Same as |vit-env| for enumerate.
:ViTEnumLeft or |<ViT>|E      Same as |vit-enum| for a left-aligned enumerate.
:ViTAlphEnum or |<ViT>|l      Same as |vit-enum| for enumerate of alphabetic
			    list items.
:ViTAlphEnumLeft or |<ViT>|L  Same as |vit-enum-alph| for a left-aligned
			    enumerate of alphabetic list items.
:ViTCenter or |<ViT>|c	    Same as |vit-env| for center.
:ViTTabular or |<ViT>|t	    Starts a tabular environment template: >
			    \begin{tabular}{#1}
				*
			    \end{tabular}
<						    *vit-math* *vit-gather*
						    *vit-equation* *vit-align*
						    *vit-proof* *vit-matrix*
:ViTEquation or |<ViT>|q      Same as |vit-env| for equation*.
:ViTGather or |<ViT>|g	    Same as |vit-env| for gather*.
:ViTAlign or |<ViT>|a	    Same as |vit-env| for align*.
:ViTAlignAt or |<ViT>|A	    Same as |vit-env| for alignat*: >
			    \begin{alignat*}{#1}
				*
			    \end{alignat*}
:ViTProof or |<ViT>|r	    Same as |vit-env| for proof.
:ViTMatrix or |<ViT>|m	    Same as |vit-env| for matrix: >
			    \begin{matrix}{#1}
				*
			    \end{matrix}
<						    *vit-math-mode*
						    *vit-parentheses*
						    *vit-overbrace* *vit-frac*
						    *vit-sqrt* *vit-root*
						    *vit-sum* *vit-lim*
:ViTMathMode or |<ViT>|$      Start text math mode template: >
			    $*$
:ViTParentheses or |<ViT>|1   Starts a left-right parentheses template: >
			    \left( * \right)
:ViTBrackets or |<ViT>|2      Same as |vit-parentheses| but with brackets ([).
:ViTBraces or |<ViT>|3	    Same as |vit-parentheses| but with braces ({).
:ViTBars or |<ViT>|4	    Same as |vit-parentheses| but with bars (|).
:ViTOverbrace or |<ViT>|<F1>  Starts a overbrace template: >
			    \overbrace{*}^{}
:ViTUnderbrace or |<ViT>|<F2> Same as |vit-overbrace| but with an underbrace.
:ViTBoxed or |<ViT>|<F3>      Starts a boxed template: >
			    \boxed{*}
:ViTFrac		    Starts a fraction template: >
			    \frac{*}{}
:ViTSqrt		    Starts a square root template: >
			    \sqrt{*}
:ViTRoot		    Same as |vit-sqrt| but for an n-th root: >
			    \sqrt[*]{}
:ViTSum			    Starts a sum template: >
			    \sum_{*}^{}
:ViTInt			    Same as |vit-sum| but for an integral.
:ViTProd		    Same as |vit-sum| but for a product.
:ViTLim			    Starts a limit template: >
			    \lim_{*}
:ViTSup			    Same as |vit-lim| but for the supremum.
:ViTInf			    Same as |vit-lim| but for the infimum.

==============================================================================
4. Insert-Mode Completion			    *vit-completion*

Insert-Mode completion works by utilizing the Vim builtin omni-func
completion (|compl-omni|). The lowest priority items are the ones read in by
|g:vit_commands|, these will be referred to as static completion items. Then,
there are template completion items, which are defined by the
|ViTNewTemplate()| function if the {completionitem} option is truthy.

Static completion items work as expected, one can select them from the
completion popup menu and they will be inserted as-is.

						    *vit-completion-start*
						    *i_<BSlash>*
<BSlash>		   Inserts \ and starts insert mode completion.
|<ViT>|<Space> or |<ViT>||<ViT>| Starts insert mode completion.

						    *vit-completion-template*
Template completion items behave the same way, but when they are inserted, the
inserted text will be replaced by the template function specified by the
internal data of the item. For instance, selecting |vit-frac| by its
completion item text '\frac{' will start up the template at the current
position. Instead of inserting '\frac{' it will insert '\frac{}{}'.

New template completion items are suggest to be added by calling
|ViTNewTemplate()| but it is also possible to manually define them using the
separate |ViTNewCompletionOption()| function.

						    *ViTNewCompletionOption()*
ViTNewCompletionOption({name}, {command})
	This function adds a new |vit-completion-template| item to insert mode
	completion.

	The argument {name} will show up in the popup menu to be selected.

	The argument {command} is the command that will be called to set the
	text to be inserted instead of {name} directly. It must be publicly
	accessible.

==============================================================================
5. Compiling					    *vit-compiling*

ViT provides a command for compiling the current buffer with a globally
specified compiler (|g:vit_compiler|) with globally specified compiler flags
(|g:vit_compiler_flags|). It then reads the log file, if it can be found, to
show signs for errors and output a status message for the compilation.

ViT also sets up an autocommand, so that writing a buffer will cause it to be
compiled with |:ViTCompile!| automatically.

						    *vit-compiling-signs*
The maximum number of error signs depends on |g:vit_max_errors|. When this is
set to 0, no signs and no status line error message will be displayed. If no
log file is found in the directory, then there will be a warning message
displayed. In either case, the status message will show whether or not the
process exited normally or with errors.

						    *:ViTCompile*
						    *:ViTCompile!*
:ViTCompile[!]
	Compiles the current buffer in the directory of the buffer.

	The non-bang version starts a terminal (|:term|), while the bang
	version starts a background |job|. You may want to use a terminal in
	case you want to carefully examine the error outputs. If you do not
	care about the exact output, you may want to use the automatic output
	features provided by ViT (|vit-compiling-signs|).

"	Shortcut for :ViTCompile.
!	Shortcut for :ViTCompile!.

==============================================================================
6. Smart Typing					    *vit-smart-typing*

ViT will automatically surround the characters provided by
|g:vit_autosurround_chars| in insert mode. It also provides a smart-move-right
shortcut in insert mode, so that LaTeX (and especially |vit-templates|) can be
traversed more efficiently.

						    *vit-autosurround*
Typing any character specified in the first index of a list entry in
|g:vit_autosurround_chars| will insert the first index of the list entry, then
the second entry, and then move the cursor back by one character.

						    *i_<S-Tab>*
<S-Tab>	    Move the cusror to the nearest found character specified in
	    |g:vit_jump_chars|, or to the end of the line, in insert mode.

==============================================================================
6. License					    *vit-license*

ViT is distributed under the Vim license. See |license| for more detials.

 vim:tw=79:ts=8:noet:ft=help:
